## synchronized底层原理
- 前言
- 一、synchronized的特性
 * 1.1原子性
 * 1.2可见性
 * 1.3有序性
 * 1.4可重入性
 
+ 二、synchronized用法
 * 1.1同步方法、static方法
 * 1.2同步代码块
+ 三、Jvm对synchronized的优化
* 1.1锁膨胀
* 1.2偏向锁
* 1.3轻量级锁
* 1.4重量级锁
* 1.5锁消除
* 1.6锁粗化
* 1.7自旋锁与自适应自旋锁

### 一、前言：
 如果某一个资源被多个线程共享，为了避免因为出现资源抢占导致资源数据错乱，我们需要对线程进行同步，那么synchronized就是实现同步的关键字。在并发控制中必不可少的部分。
 ### 二、synchronized特性：
 #### 1.原子性：
 所谓原子性就是指一个或者多个操作，要么全部执行并且执行过程中不会因为任何因素被打断，要么就都不执行。被synchronize修饰的类或者对象它们的所有操作都是原子性的，因为住在执行操作之前必须获得类或者对象的锁，直到执行完才能释放，在这期间是不能中断的，所以保证了原子性。
 注意：synchronize和volatile区别在于，synchronize可以保证原子性而volatile不能保证原子性。
 #### 2.可见性：
 可见性是指多个线程访问一个资源时，该资源的状态，值信息等对其他线程都是可见状态。
 synchronize和volatile都具有可见性，其中synchronize对一个类或者对象加锁时，一个线程访问该类或者对象要先获取它们的锁，而这个锁的状态对其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程必须在锁池中等待锁释放。
 而volatile实现类似，被volatile修饰的变量，每当值需要修改时都会立即刷新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的永远是最新值，保证可见性。
 #### 3.有序性：
 有序性值程序执行顺序按照代码先后顺序
 synchronize和volatile都具有有序性，synchronize保证了同一时刻只有一个线程对同步代码块进行访问，也就确定了线程的执行顺序，保证了线程的有序性。
 #### 4.可重入性：
 synchronized和ReentranLock都是可重入锁，当一个线程试图操作一个由其他线程持有对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自身持有对象锁临界资源时，这种情况属于重入锁，通俗一点讲就是一个线程拥有了锁仍然还可以重复申请锁。
 ### 原理：
 对class文件进行反编译之后发现synchronize是由monitor进行控制的，monitorenter开始 monitorexit结束
 Java中对象是分三部分存储的：对象实例，对象头，实例数据，对齐填充。
  对象头：是synchronize锁实现的基础，因为synchronize申请锁，上锁，释放锁都与对象的头有关，对象头信息主要包括：mark Word 和class metadata address 
  其中Mark Word存储对象的hashcode、锁信息或分代年龄或GC标志等信息。
  class metadata address是类型指针指向对象的类元数据，jvm通过该指针确定该对象是哪个类的实例。
  锁也分状态，JDK1.6之前只有两个状态，即：有锁（重量级锁） 无锁，JDK1.6之后对锁进行了优化，新增两种状态，即:无锁状态，偏向锁状态，轻量级锁，重量级锁，锁的类型和状态在对象头mark Word 里边都有记录，在申请锁，锁升级的过程中jvm都要获取对象头信息。
  ### 锁膨胀
  锁膨胀，根据实际情况进行锁膨胀升级，膨胀方向为：无锁状态----->偏向锁----->轻量级锁---->重量级锁，并且膨胀方向不可逆。
  ### 核心思想：
  当一个线程获取了锁，那么锁就进入偏向模式，此时Mark Word的结构就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word中锁标记为偏向锁以及当前线程ID等于Mark Word中的ThreadID即可，这样省去了大量有关锁申请的操作。
