## synchronized底层原理
- 前言
- 一、synchronized的特性
 * 1.1原子性
 * 1.2可见性
 * 1.3有序性
 * 1.4可重入性
 
+ 二、synchronized用法
 * 1.1同步方法、static方法
 * 1.2同步代码块
+ 三、Jvm对synchronized的优化
* 1.1锁膨胀
* 1.2偏向锁
* 1.3轻量级锁
* 1.4重量级锁
* 1.5锁消除
* 1.6锁粗化
* 1.7自旋锁与自适应自旋锁

### 一、前言：
 如果某一个资源被多个线程共享，为了避免因为出现资源抢占导致资源数据错乱，我们需要对线程进行同步，那么synchronized就是实现同步的关键字。在并发控制中必不可少的部分。
 ### 二、synchronized特性：
 #### 1.原子性：
 所谓原子性就是指一个或者多个操作，要么全部执行并且执行过程中不会因为任何因素被打断，要么就都不执行。被synchronize修饰的类或者对象它们的所有操作都是原子性的，因为住在执行操作之前必须获得类或者对象的锁，直到执行完才能释放，在这期间是不能中断的，所以保证了原子性。
 注意：synchronize和volatile区别在于，synchronize可以保证原子性而volatile不能保证原子性。
 #### 2.可见性：
 可见性是指多个线程访问一个资源时，该资源的状态，值信息等对其他线程都是可见状态。
 synchronize和volatile都具有可见性，其中synchronize对一个类或者对象加锁时，一个线程访问该类或者对象要先获取它们的锁，而这个锁的状态对其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程必须在锁池中等待锁释放。
 而volatile实现类似，被volatile修饰的变量，每当值需要修改时都会立即刷新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的永远是最新值，保证可见性。
 #### 3.有序性：
 有序性值程序执行顺序按照代码先后顺序
 synchronize和volatile都具有有序性，synchronize保证了同一时刻只有一个线程对同步代码块进行访问，也就确定了线程的执行顺序，保证了线程的有序性。
 #### 4.可重入性：
 synchronized和ReentranLock都是可重入锁，当一个线程试图操作一个由其他线程持有对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自身持有对象锁临界资源时，这种情况属于重入锁，通俗一点讲就是一个线程拥有了锁仍然还可以重复申请锁。
